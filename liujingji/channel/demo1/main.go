package main

import "fmt"

/**
  1、容量为0时，通道为非缓冲通道
  2、容量大于0时，通道为缓冲通道

  3、一个通道相当于一个先进先出的队列

  4、元素值的发送和接收都需要用到操作符<-即接送操作符

  5、元素值从外界进入通道时会被复制即进入的是操作符右边的那个元素值的副本而不是它本身

*/
func main() {
	ch1 := make(chan int, 3)
	/**
	发送1到通道ch1中,分两步
	1、复制元素值
	2、防止副本到通道内部
	*/
	ch1 <- 1
	fmt.Printf("ch1的长度: %v\n", len(ch1))
	ch1 <- 2
	fmt.Printf("ch1的长度: %v\n", len(ch1))
	ch1 <- 3
	fmt.Printf("ch1的长度: %v\n", len(ch1))
	/**
	从通道ch1中接收元素,分三步：
	1、生成正在通道中的这个元素值的副本
	2、放置副本到接收方
	3、删除在通道中的这个元素值
	*/
	elem1 := <-ch1
	fmt.Printf("从通道ch1接收的第一个元素是: %v\n", elem1)

}

/**
Q: 对通道的发送和接收操作都有哪些基本的特性？
A:
1、对于同一个通道，发送操作之间是互斥的，接收操作之间也是互斥的
2、发送操作和接收操作中对元素值的处理都是不可分隔的。发送操作要么还没复制元素值，要么已经复制完毕，绝不会出现只复制了一部分的情况；接收操作在准备好元素值的副本之后，一定会删除掉通道中的原值，绝不会出现通道中仍有残留的情况
3、发送操作在完全完成之前会被阻塞。接收操作也是如此
*/

/**
Q: 发送操作和接收操作在什么情况下会被长时间阻塞
A:
1、缓冲通道已满，对它的所有发送操作都会阻塞，直到通道中有元素被接收走。通道会依次通知因阻塞而等待的发送操作所在的goroutine, 依次继续执行发送操作。
2、缓冲通道已空，对它的所有接收操作都会被阻塞，直到通道中有新的元素值出现。通道会依次通知因阻塞而等待的接收操作所在的goroutine，依次继续执行接收操作

3、非缓冲通道，无论发送操作还是接收操作，一开始执行就会被阻塞，知道配对的操作也开始执行，才会继续传递。由此可见，费缓冲通道是在用同步的方式传递数据。数据也是直接从发送方复制到接收方的，中间并不会用非缓冲通道做中转
4、缓冲通道是作为收发双方的中间件。但是，当发送操作在执行的时候发现空的通道中，正好有等待的接收操作，那么它会直接把元素值复制给接收方。
5、通道类型是引用类型，零值是nil。对值为nil的通道，发送操作和接收操作都会造成永久的阻塞
*/
